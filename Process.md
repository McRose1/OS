# Process（进程）
## 定义
### 进程
是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.

每一个进程都有一个自己的地址空间，即进程空间或（虚空间）。

大小只与处理机的位数有关，一16位处理机的空间大小为216 ，而 32 位处理机的进程空间大小为 232 。

进程至少有 5 种基本状态，它们是：**初始态，执行态，等待状态，就绪状态，终止状态** 。

单机系统中进程通信有 4 种形式：主从式，会话式，消息或邮箱机制，共享存储区方式，管道（共享大量内存中的数据）。
### 线程
是进程的一个实体, **是CPU调度和分派的基本单位** ,它是比进程更小的能独立运行的基本单位.
线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈，非共享),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.

## 区别
1) 包含关系:一个程序至少有一个进程,一个进程至少有一个线程.

2) 内存共享：进程在执行过程中拥有独立的内存单元(一个进程崩溃后，在保护模式下不会对其它进程产生影响)；而多个线程共享进程提供的内存(拥有自己的私有栈空间只是作为运行需要的极少内存)，从而极大地提高了程序的运行效率，但一个线程死掉就等于整个进程死掉。所以多进程的程序要比多线程的程序健壮

3) 执行过程：进程独立执行；线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

4) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
## IPC（进程间通信）
### 进程通信
进程的用户空间是互相独立的，一般而言是不能互相访问的，唯一的例外是共享内存区。
但是，系统空间却是“公共场所”，所以内核显然可以提供这样的条件。
除此以外，那就是双方都可以访问的外设了。
在这个意义上，两个进程当然也可以通过磁盘上的普通文件交换信息，或者通过“注册表”或其它数据库中的某些表项和记录交换信息。
广义上这也是进程间通信的手段，但是一般都不把这算作“进程间通信”。因为那些通信手段的效率太低了，而人们对进程间通信的要求是要有一定的实时性。 

进程间通信主要包括管道, 系统IPC(包括消息队列,信号量,共享存储), SOCKET.

管道包括三种:
1) 普通管道PIPE, 通常有种限制,一是半双工,只能单向传输;二是只能在父子进程间使用. 
2) 流管道s_pipe: 去除了第一种限制,可以双向传输. 
3) 命名管道:name_pipe, 去除了第二种限制,可以在许多并不相关的进程之间进行通讯.

系统IPC的三种方式类同,都是使用了内核里的标识符来识别. 

管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。

信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的（共享大量内存中的数据）。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

## 在Linux上，对于多进程，子进程继承了父进程的下列哪些?

### 子进程继承父进程
- 用户号UIDs和用户组号GIDs 
- 环境Environment 
- 堆栈 
- 共享内存 
- 打开文件的描述符 
- 执行时关闭（Close-on-exec）标志 
- 信号（Signal）控制设定 
- 进程组号 
- 当前工作目录 
- 根目录 
- 文件方式创建屏蔽字 
- 资源限制 
- 控制终端

### 子进程独有
- 进程号PID 
- 不同的父进程号 
- 自己的文件描述符和目录流的拷贝 
- 子进程不继承父进程的进程正文（text），数据和其他锁定内存（memory locks） 
- 不继承异步输入和输出

父进程和子进程拥有独立的地址空间和PID参数。

### sleep() 和 wait() 有什么区别？

- 类的不同：sleep() 来⾃ Thread，wait() 来⾃ Object。
- 释放锁：sleep() 不释放锁；wait() 释放锁。
- ⽤法不同：sleep() 时间到会⾃动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。

### notify()和 notifyAll()有什么区别？

notifyAll()会唤醒所有的线程，notify()之后唤醒⼀个线程。notifyAll() 调⽤后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执⾏，如果不成功则留在锁池等待锁被释放后再次参与竞争。⽽ notify()只会唤醒⼀个线程，具体唤醒哪⼀个线程由虚拟机控制。

